"""
adapted from:
https://github.com/c0d3z3r0/sudo-CVE-2017-1000367/sudopwn.c
"""
import os
from exploits.exploit import LinuxExploit
from src.kernels import KernelWindow
from constants import PLAYGROUND_PATH, LINUX_EXPLOIT_SOURCE_PATH, HIGH_RELIABILITY, color_print, GENERIC_LINUX, \
	POTENTIALLY_VULNERABLE, ARCHITECTURE_i686
class CVE20171000367(LinuxExploit):
	def __init__(self):
		super().__init__()
		self.name = "CVE20171000367"
		self.formatted_name = "CVE-2017-1000367"
		self.type = "linux"
		self.brief_desc = "sudo get_process_ttyname() root priv esc"
		self.reliability = HIGH_RELIABILITY
		self.architecture = ARCHITECTURE_i686
		self.vulnerable_kernels = [
			KernelWindow(GENERIC_LINUX, POTENTIALLY_VULNERABLE, 0, 0, 0, 4, 20, 0)
		]
		self.source_c_path = os.path.join(LINUX_EXPLOIT_SOURCE_PATH, "{}.c".format(self.name))
		self.compilation_path = os.path.join(PLAYGROUND_PATH, self.name)
		self.compilation_command = "gcc -o {} {}".format(self.compilation_path, self.source_c_path)
		self.exploit_command = self.compilation_path

	def determine_vulnerability(self):
		"""
		For this vulnerability the following prerequisites have to be satisfied:
			- sudo version < 1.8.21
			- system must be selinux-enabled
			- sudo needs to be build with selinux support (sudo -r)
			- user needs to have sudo permissions: e.g. 'toor ALL=(ALL)NOPASSWD: /usr/bin/sum

		:return: True if vulnerable, False if not
		"""
		color_print("\t[*] checking exploitation prerequisites for {}".format(self.name), color="blue")
		sudo_version_command = "sudo -V"
		se_linux_enabled_command = "cat/etc/selinux/config"		# SELINUX=disabled not in output
		sudo_built_with_selinux_support_command = "sudo -r" 		# if 'role' is in output, it's supported
		sudo_permissions_check_command = "sudo -l" 				# if not 'may not run' in output
		sv_output = 		self.shell_results(sudo_version_command)
		sle_output = 		self.shell_results(se_linux_enabled_command)
		sbwssc_output = 	self.shell_results(sudo_built_with_selinux_support_command)
		spc_output = 		self.shell_results(sudo_permissions_check_command)


		sv_std_out = 	sv_output[0].decode('utf-8')
		major_v = 		int(sv_std_out.split(" ")[2].split(".")[0])
		minor_v = 		int(sv_std_out.split(" ")[2].split(".")[1])
		release_v = 	int(sv_std_out.split("\n")[0].split(" ")[2].split(".")[2].split("p")[0])
		if not major_v <= 1 and minor_v <= 8 and release_v <= 20:
			self.exploit_failure("sudo version {} is not less than 1.8.21")
			return False
		color_print("\t[+] sudo version {} is vulnerable (less than 1.8.21)".format(
			"{}.{}.{}".format(major_v, minor_v, release_v)))

		sle_std_out = 	sle_output[0].decode('utf-8')
		sle_std_err = 	sle_output[1].decode('utf-8')
		if "No such file" in sle_std_err or not \
			"SELINUX=disabled" in sle_std_out:
			self.exploit_failure("system does not appear to be selinux-enabled")
			return False
		color_print("\t[+] system appears to be selinux-enabled")

		sbwssc_std_out = sbwssc_output[0].decode('utf-8')
		if not "role" in sbwssc_std_out:
			self.exploit_failure("sudo does not appear to be built with selinux support")
			return False
		color_print("\t[+] sudo appears to be built with selinux support")

		spc_std_out = spc_output[0].decode('utf-8')
		spc_std_err = spc_output[1].decode('utf-8')
		if "may not run" in spc_std_err:
			self.exploit_failure("user is not a sudoer")
			return False
		color_print("\t[+] user appears to be a sudoer")

		color_print("\t[+] system appears to be vulnerable to {}".format(self.name), color="green")
		return True

	def exploit(self):
		self.exploit_failure("this exploit requires manual review. source at {}".format(self.source_c_path))